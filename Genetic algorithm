#GA 알고리즘
import numpy as np
import csv
import random
import matplotlib.pyplot as plt

# Function to measure Euclidean distance between two points
def distance(x, y):
    return np.linalg.norm(np.array(x) - np.array(y))

def initialize_population(num_cities, population_size=50):
    population = []
    for _ in range(population_size):
        # Start with a list of all city indices
        solution = list(range(num_cities))
        # Remove the first city index to keep it fixed
        first_city = solution.pop(0)
        # Shuffle the remaining cities
        random.shuffle(solution)
        # Prepend the fixed first city back to the start
        solution.insert(0, first_city)
        population.append(solution)
    return population

# Function to evaluate the cost of each solution in the population
def evaluate_population(population, cities):
    scores = []
    for sol in population:
        total_cost = 0
        for idx in range(len(sol) - 1):
            pos_city_1 = cities[sol[idx]]
            pos_city_2 = cities[sol[idx+1]]
            total_cost += distance(pos_city_1, pos_city_2)
        scores.append(total_cost)
    return scores
#Selection
def selection(population, scores, num_best):
    solutions = select_best(population, scores, num_best)
    return random.sample(solutions, 2)
# Function to select the best solutions for reproduction
def select_best(population, scores, num_best):
    sorted_population = [x for _, x in sorted(zip(scores, population), key=lambda pair: pair[0])]
    return sorted_population[:num_best]

# Function to perform crossover between two solutions
def crossover(parent1, parent2):
    cut = random.randint(1, len(parent1) - 1)
    child = parent1[:cut] + [x for x in parent2 if x not in parent1[:cut]]
    return child

# Function to perform mutation in a solution
def mutate(solution, mutation_rate=0.05):
    for i in range(len(solution)):
        if i != 0 and random.random() < mutation_rate:
            j = random.randint(1, len(solution) - 1)
            solution[i], solution[j] = solution[j], solution[i]
    return solution

# Plot function modification to include the start point at (0,0)
def plot_path(solution, cities, generation):
    plt.figure(figsize=(12, 8))
    x = [cities[i][0] for i in solution]
    y = [cities[i][1] for i in solution]

    # Plot the path
    plt.plot(x, y, 'b-', alpha=0.3, linewidth=1, label=f"Generation {generation}")
    plt.scatter(x, y, color='blue', s=5, label='Cities')  # Scatter plot for cities

    # Highlight the start point (0,0)
    plt.scatter(cities[0][0], cities[0][1], c='red', s=100, zorder=10, label='Start (0,0)')

    plt.title("TSP Route Visualization")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.legend()
    plt.grid(True)
    plt.show()


# Assuming 'best_solution' and 'cities' are defined from the GA process
# Example usage
# plot_path(best_solution, cities, generation)

# Read city data from CSV
cities = []
with open('2024_AI_TSP.csv', mode='r', newline='') as tsp:
    reader = csv.reader(tsp)
    first_row = next(reader)  # 첫 번째 행을 읽어 첫 번째 도시 (시작점)로 사용
    cities.append([float(first_row[0]), float(first_row[1])])
    for row in reader:
        cities.append([float(row[0]), float(row[1])])

# Initialize population
population_size = 50
num_cities = len(cities)
population = initialize_population(num_cities, population_size)

# Evaluate initial population
scores = evaluate_population(population, cities)

# Genetic algorithm parameters
generations = 100
num_best = 10

# Genetic algorithm main loop!!!!!
best_score = float('inf')
best_solution = None
for generation in range(generations+1):

    # Crossover and mutation
    new_population = []
    while len(new_population) < population_size:
        parent1, parent2 = selection(population, scores, num_best)
        child = crossover(parent1, parent2)
        child = mutate(child)

        new_population.append(child)

    population = new_population
    scores = evaluate_population(population, cities)

    # Find the best solution for this generation
    generation_best_score = min(scores)
    generation_best_index = scores.index(generation_best_score)
    generation_best_solution = population[generation_best_index]

    # Update the overall best solution if the new one is better
    if generation_best_score < best_score:
        best_score = generation_best_score
        best_solution = generation_best_solution

    # Plot best solution for this generation
    if generation % 10 == 0:  # Plot every 10 generations
        print('Best solution cost at generation', generation, ':', generation_best_score)

# Output the best solution found
plot_path(best_solution, cities, generation)
print('Best solution cost at all:', best_score)
print('Best solution sequence:', best_solution)
